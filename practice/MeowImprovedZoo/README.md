# Интерфейсы:

- IAlive: Определяет, что объект является "живым" и имеет свойство food (количество еды в сутки).

- IInventory: Определяет, что объект может быть инвентаризирован и имеет свойство number (инвентаризационный номер).

# Классы животных:

- Animal: Базовый класс для всех животных. Реализует интерфейсы IAlive и IInventory. Содержит общие свойства, такие как количество еды, инвентаризационный номер и состояние здоровья.

- Herbo и Predator: Классы-наследники Animal, представляющие травоядных и хищников. У травоядных добавлено свойство kindnessLevel (уровень доброты), которое определяет, может ли животное взаимодействовать с посетителями.

- Конкретные классы животных: Monkey, Rabbit, Tiger, Wolf. Наследуются от Herbo или Predator в зависимости от их типа.

# Классы для вещей:

- Thing: Базовый класс для инвентаризируемых вещей. Реализует интерфейс IInventory.

- Конкретные классы вещей: Table, Computer. Наследуются от Thing.

# Класс Zoo:

Управляет всеми животными и вещами в зоопарке.

Методы:

- addAnimal: Добавляет животное в зоопарк после проверки его здоровья.

- calculateTotalFood: Рассчитывает общее количество еды, необходимое для всех животных.

- getAnimalsForContactZoo: Возвращает список животных, которые могут быть помещены в контактный зоопарк (травоядные с уровнем доброты выше 5).

- addThing: Добавляет вещь в инвентарь.

- printInventory: Выводит информацию о всех животных и вещах, стоящих на балансе зоопарка.

---

# Принципы SOLID в проекте

## Принцип единственной ответственности (Single Responsibility Principle, SRP):

Каждый класс отвечает за одну задачу. Например:

- Animal отвечает за хранение данных о животном.

- Zoo отвечает за управление животными и вещами.

- VeterinaryClinic отвечает за проверку здоровья животных.

## Принцип открытости/закрытости (Open/Closed Principle, OCP):

Классы открыты для расширения, но закрыты для модификации. Например:

- Добавление новых типов животных (например, Lion или Elephant) не требует изменения существующих классов Animal, Herbo или Predator.

- Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP):

- Наследники класса Animal (например, Herbo и Predator) могут использоваться вместо базового класса без изменения поведения программы.

## Принцип разделения интерфейса (Interface Segregation Principle, ISP):

- Интерфейсы IAlive и IInventory разделены, чтобы классы не зависели от методов, которые они не используют. Например, класс Thing реализует только IInventory, а класс Animal реализует оба интерфейса.

## Принцип инверсии зависимостей (Dependency Inversion Principle, DIP):

- Классы зависят от абстракций (интерфейсов), а не от конкретных реализаций. Например:

- Класс Zoo зависит от интерфейса IAlive для работы с животными, а не от конкретных классов животных.

---

# Использование DI-контейнера

DI-контейнер используется для управления зависимостями между компонентами системы. Например:

1. Внедрение зависимости в класс Zoo:

- Класс Zoo зависит от сервиса ветеринарной клиники (VeterinaryClinic), который проверяет здоровье животных. Вместо создания экземпляра VeterinaryClinic внутри Zoo, зависимость внедряется через конструктор.

2. Преимущества DI:

- Упрощает тестирование (можно использовать mock-объекты для VeterinaryClinic).

- Упрощает расширение системы (можно легко заменить реализацию VeterinaryClinic).

- Уменьшает связанность между компонентами.

---

# Инструкция по запуску main: 

1. Запустить ./gradlew bootRun

# Также, можно запустить тесты и проверить покрытие через плагин JaCoCo.

1. Запустить ./gradlew test (результаты в build/reports/tests/test/index.html)

2. Посмотреть покрытие тестов JaCoCo (build/reports/jacoco/test/html/index.html)

# Готово!