package hse.zoo.Presentation.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;

@Configuration
public class SwaggerConfig {
    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("HSE Zoo Service API")
                        .version("1.0")
                        .description("API для управления зоопарком"));
    }
}package hse.zoo.Presentation.controllers;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import java.util.List;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;
import io.swagger.v3.oas.annotations.Operation;
import org.springframework.web.bind.annotation.RequestBody;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

import hse.zoo.Application.facade.ZooFacade;
import hse.zoo.Domain.entities.FeedingSchedule;
import hse.zoo.Presentation.request.CreateFeedingScheduleRequest;

@RestController
@RequestMapping("/api/schedules")
@RequiredArgsConstructor
@Tag(name = "Расписания кормления", description = "Управление расписаниями кормления")
public class FeedingScheduleController {
    private final ZooFacade zooFacade;

    @GetMapping("/get/{id}")
    @Operation(summary = "Получить расписание по id")
    public ResponseEntity<FeedingSchedule> getScheduleById(@PathVariable int id) {
        try {
            FeedingSchedule tmp = zooFacade.getSchedule(id);
            return ResponseEntity.ok(tmp);
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    e.getMessage());        
        }
    }
    
    @PostMapping("/add")
    @Operation(summary = "Добавить расписание")
    public ResponseEntity<String> addSchedule(
            @Valid @RequestBody CreateFeedingScheduleRequest request,
            BindingResult bindingResult) {

        if (bindingResult.hasErrors()) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    bindingResult.getAllErrors().get(0).getDefaultMessage());
        }

        try {
            Integer animalId = request.animalId();
            String feedingTime = request.time();
            Boolean foodType = request.foodType();
            Date feedingTimeDate = Date.from(LocalDateTime.parse(feedingTime, DateTimeFormatter.ofPattern("HH:mm")).atZone(ZoneId.systemDefault()).toInstant());
            Integer scheduleId = zooFacade.addFeedingSchedule(animalId, feedingTimeDate, foodType);
            return ResponseEntity.status(HttpStatus.CREATED).body("Добавлено расписание с id " + scheduleId);
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
            e.getMessage());    
        }
    }

    @DeleteMapping("/delete/{id}")
    @Operation(summary = "Удалить расписание")
    public ResponseEntity<String> DeleteSchedule(@PathVariable int id) {
        try {
            zooFacade.deleteFeedingSchedule(id);
            return ResponseEntity.ok("Вольер с id " + id + " удалён");
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    e.getMessage());        
        }
    }

    @PutMapping("/change/{id}")
    @Operation(summary = "Изменить расписание")
    public ResponseEntity<String> changeSchedule(@PathVariable int id,
            @Valid @RequestBody CreateFeedingScheduleRequest request,
            BindingResult bindingResult) {

        if (bindingResult.hasErrors()) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    bindingResult.getAllErrors().get(0).getDefaultMessage());
        }

        try {
            Integer animalId = request.animalId();
            String feedingTime = request.time();
            Boolean foodType = request.foodType();
            Date feedingTimeDate = Date.from(LocalDateTime.parse(feedingTime, DateTimeFormatter.ofPattern("HH:mm")).atZone(ZoneId.systemDefault()).toInstant());
            zooFacade.changeSchedule(id, animalId, feedingTimeDate, foodType);
            return ResponseEntity.ok("Расписание с id " + id + " изменено");
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    e.getMessage());        
        }
    }

    @GetMapping("/all")
    @Operation(summary = "Получить все расписания")
    public ResponseEntity<List<FeedingSchedule>> getAllSchedules() {
        try {
            List<FeedingSchedule> schedules = zooFacade.getSchedules();
            return ResponseEntity.ok(schedules);
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    e.getMessage());        
        }
    }

    // TODO: Сделать где-нибудь, как-нибудь checkIfFed
    
}package hse.zoo.Presentation.controllers;

import java.util.List;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;
import io.swagger.v3.oas.annotations.Operation;
import org.springframework.web.bind.annotation.RequestBody;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

import hse.zoo.Application.facade.ZooFacade;
import hse.zoo.Domain.entities.Enclosure;
import hse.zoo.Presentation.request.CreateEnclosureRequest;

@RestController
@RequestMapping("/api/enclosures")
@RequiredArgsConstructor
@Tag(name = "Вольеры", description = "Управление вольерами")
public class EnclosureController {
    private final ZooFacade zooFacade;

    @GetMapping("/get/{id}")
    @Operation(summary = "Получить вольер по id")
    public ResponseEntity<Enclosure> getEnclosureById(@PathVariable int id) {
        try {
            Enclosure tmp = zooFacade.getEnclosure(id);
            return ResponseEntity.ok(tmp);
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    e.getMessage());        
        }
    }
    
    @PostMapping("/add")
    @Operation(summary = "Добавить вольер")
    public ResponseEntity<String> addEnclosure(
            @Valid @RequestBody CreateEnclosureRequest request,
            BindingResult bindingResult) {

        if (bindingResult.hasErrors()) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    bindingResult.getAllErrors().get(0).getDefaultMessage());
        }

        try {
            List<String> species = List.of(request.species().split(" "));
            Integer width = request.width();
            Integer height = request.height();
            Integer length = request.length();
            Integer maxAnimalCount = request.maxAnimalCount();
            Integer enclosureId = zooFacade.addEnclosure(species, width, height, length, maxAnimalCount);
            return ResponseEntity.status(HttpStatus.CREATED).body("Добавлен вольер с id " + enclosureId);
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
            e.getMessage());    
        }
    }

    @DeleteMapping("/delete/{id}")
    @Operation(summary = "Удалить вольер")
    public ResponseEntity<String> DeleteEnclosure(@PathVariable int id) {
        try {
            zooFacade.deleteEnclosure(id);
            return ResponseEntity.ok("Вольер с id " + id + " удалён");
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    e.getMessage());        
        }
    }

    @GetMapping("/get/all")
    @Operation(summary = "Получить все вольеры")
    public ResponseEntity<String> getAllEnclosures() {
        try {
            List<Enclosure> enclosures = zooFacade.getEnclosures();
            return ResponseEntity.ok("Вольеры: \n" + enclosures.toString());
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    e.getMessage());        
        }
    }
    
    @GetMapping("/get/empty")
    @Operation(summary = "Получить пустые вольеры")
    public ResponseEntity<String> getEmptyEnclosures() {
        try {
            List<Enclosure> enclosures = zooFacade.getEmptyEnclosures();
            return ResponseEntity.ok("Пустые вольеры: \n" + enclosures.toString());
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    e.getMessage());        
        }
    }
}package hse.zoo.Presentation.controllers;

import java.util.Date;
import java.util.List;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;
import io.swagger.v3.oas.annotations.Operation;
import org.springframework.web.bind.annotation.RequestBody;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

import hse.zoo.Application.facade.ZooFacade;
import hse.zoo.Domain.entities.Animal;
import hse.zoo.Presentation.request.CreateAnimalRequest;

@RestController
@RequestMapping("/api/animals")
@RequiredArgsConstructor
@Tag(name = "Животные", description = "Управление животными")
public class AnimalContoller {
    private final ZooFacade zooFacade;

    @GetMapping("/get/{id}")
    @Operation(summary = "Получить животное по id")
    public ResponseEntity<Animal> getAnimalById(@PathVariable int id) {
        try {
            Animal tmp = zooFacade.getAnimal(id);
            return ResponseEntity.ok(tmp);
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    e.getMessage());        
        }
    }
    
    @PostMapping("/add")
    @Operation(summary = "Добавить животное")
    public ResponseEntity<String> addAnimal(
            @Valid @RequestBody CreateAnimalRequest request,
            BindingResult bindingResult) {

        if (bindingResult.hasErrors()) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    bindingResult.getAllErrors().get(0).getDefaultMessage());
        }

        try {
            Integer enclosureId = request.enclosureId();
            String species = request.species();
            String name = request.name();
            Date birthDate = request.birthDate();
            Boolean sex = request.sex();
            String favouriteFood = request.favouriteFood();
            Boolean isHealthy = request.isHealthy();
            Integer animalId = zooFacade.addAnimal(enclosureId, name, birthDate, sex, favouriteFood, isHealthy, species);
            return ResponseEntity.status(HttpStatus.CREATED).body("Добавлено животное с id " + animalId);
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
            e.getMessage());    
        }
    }

    @DeleteMapping("/delete/{id}")
    @Operation(summary = "Удалить животное")
    public ResponseEntity<String> DeleteAnimal(@PathVariable int id) {
        try {
            zooFacade.deleteAnimal(id);
            return ResponseEntity.ok("Животное с id " + id + " удалён");
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    e.getMessage());        
        }
    }

    @PostMapping("/transfer/{animalId}/{enclosureId}")
    @Operation(summary = "Перевести животное в вольер")
    public ResponseEntity<String> TransferAnimal(@PathVariable int animlaId, @PathVariable int enclosureId) {
        try {
            zooFacade.transferAnimalToEnclosure(animlaId, enclosureId);
            return ResponseEntity.ok("Животное с id" + animlaId + " переведено в вольер с id " + enclosureId);
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    e.getMessage());        
        }
    }
    
    @GetMapping("/get/all")
    @Operation(summary = "Получить всех животных")
    public ResponseEntity<String> getAllAnimals() {
        try {
            List<Animal> animals = zooFacade.getAnimals();
            return ResponseEntity.ok("Животное: \n" + animals.toString());
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    e.getMessage());        
        }
    }

    @GetMapping("/get/{enclosureId}")
    @Operation(summary = "Получить животных в вольере")
    public ResponseEntity<String> getAnimalsInEnclosure(@PathVariable int enclosureId) {
        try {
            List<Animal> animals = zooFacade.getAnimalsInEnclosure(enclosureId);
            return ResponseEntity.ok("Животные в вольере с id " + enclosureId + ": \n" + animals.toString());
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    e.getMessage());        
        }
    }

    @GetMapping("/get/ill")
    @Operation(summary = "Получить заболевших животных")
    public ResponseEntity<String> getIllAnimals() {
        try {
            List<Animal> animals = zooFacade.getIllAnimals();
            return ResponseEntity.ok("Больные животные: \n" + animals.toString());
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    e.getMessage());        
        }
    }

    @PutMapping("/heal/{animalId}")
    @Operation(summary = "Лечить животное")
    public ResponseEntity<String> healAnimal(@PathVariable int animalId) {
        try {
            zooFacade.healAnimal(animalId);
            return ResponseEntity.ok("Животное с id " + animalId + " вылечено");
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    e.getMessage());        
        }
    }

    @GetMapping("/get/freeAnimals")
    @Operation(summary = "Получить животных вне вольера")
    public ResponseEntity<String> getFreeAnimals() {
        try {
            List<Animal> animals = zooFacade.getAnimalsWithoutEnclosure();
            return ResponseEntity.ok("Животные вне вольера: \n" + animals.toString());
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    e.getMessage());        
        }
    }
}package hse.zoo.Presentation.request;

import java.util.Date;

import org.springframework.lang.Nullable;

import io.swagger.v3.oas.annotations.media.Schema;

public record CreateAnimalRequest(
        @Schema(description = "ID вольера", example = "Если вольера нет, то null")
        @Nullable
        Integer enclosureId,

        @Schema(description = "Вид животного", example = "Тигр")
        String species,

        @Schema(description = "Имя животного", example = "Мурзик")
        String name,

        @Schema(description = "Дата рождения животного", example = "2022-01-01")
        Date birthDate,

        @Schema(description = "Пол животного", example = "0 - мужской, 1 - женский")
        Boolean sex,

        @Schema(description = "Любимая еда животного", example = "Курятина")
        String favouriteFood,

        @Schema(description = "Состояние здоровья животного", example = "0 - болеет, 1 - здоров")
        Boolean isHealthy
) {}package hse.zoo.Presentation.request;

import io.swagger.v3.oas.annotations.media.Schema;

public record CreateFeedingScheduleRequest(
    @Schema(description = "ID животного", example = "1")
    Integer animalId,

    @Schema(description = "Время приема пищи", example = "12:00")
    String time,

    @Schema(description = "Тип пищи", example = "0 - для травоядных, 1 - для хищников")
    Boolean foodType
    
) {}package hse.zoo.Presentation.request;

import io.swagger.v3.oas.annotations.media.Schema;

public record CreateEnclosureRequest(
        @Schema(description = "Тип вольера", example = "хищники рыбы птицы")
        String species,

        @Schema(description = "Ширина вольера в метрах", example = "100")
        Integer width,

        @Schema(description = "Высота вольера в метрах", example = "100")
        Integer height,

        @Schema(description = "Длина вольера в метрах", example = "100")
        Integer length,

        @Schema(description = "Максимальное количество животных в вольере", example = "100")
        Integer maxAnimalCount
) {}package hse.zoo.Presentation.exception;

import lombok.Getter;

@Getter
public class SwaggerException extends RuntimeException {
    private final int code;

    public SwaggerException(int code, String message) {
        super(message);
        this.code = code;
    }
}package hse.zoo.Presentation.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice(basePackages = "hse.zoo")
public class SwaggerExceptionHandler {
    @ExceptionHandler(SwaggerException.class)
    public ResponseEntity<SwaggerException> handleKpoException(SwaggerException ex) {
        return ResponseEntity.status(HttpStatus.valueOf(ex.getCode()))
                .body(ex);
    }

    @ExceptionHandler(Error.class)
    public ResponseEntity<SwaggerException> handleError(Error error) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new SwaggerException(HttpStatus.INTERNAL_SERVER_ERROR.value(), error.getMessage()));
    }
}package hse.zoo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
@ComponentScan
public class Zoo {
    public static void main(String[] args) {

        SpringApplication.run(Zoo.class, args);

    }
}package hse.zoo.Domain.entities;

import java.util.Date;

import hse.zoo.Domain.valueobjects.FavouriteFood;
import hse.zoo.Domain.valueobjects.AnimalSpecies;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.ToString;

@RequiredArgsConstructor
@ToString
public class Animal {

    @Getter
    private Enclosure enclosure;

    private String name;

    private Date birthDate;

    private Boolean sex; // 0 - male, 1 - female

    private FavouriteFood favouriteFood;

    @Getter
    private Boolean isHealthy;

    @Getter
    private AnimalSpecies species;

    public Animal(String species, String name, Date birthDate, Boolean sex, String favouriteFood, Boolean isHealthy) {
        this.species = new AnimalSpecies(species);
        this.name = name;
        this.birthDate = birthDate;
        this.sex = sex;
        this.favouriteFood = new FavouriteFood(favouriteFood);
        this.isHealthy = isHealthy;
    }
    
    public Animal feed() {
        System.out.println("Животное поело.");
        return this;
    }

    public Animal heal() {
        this.isHealthy = true;
        return this;
    }

    public Animal moveTo(Enclosure enclosure) {
        this.enclosure = enclosure;
        return this;
    }
}package hse.zoo.Domain.entities;

import java.util.Date;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.ToString;

@RequiredArgsConstructor
@ToString
public class FeedingSchedule {

    @Getter
    private Animal animal;

    @Getter
    private Date feedingTime;

    @Getter
    private Boolean foodType; // 0 - vegetables, 1 - meat

    public FeedingSchedule(Animal animal, Date feedingTime, Boolean foodType) {
        this.animal = animal;
        this.feedingTime = feedingTime;
        this.foodType = foodType;
    }

    public FeedingSchedule changeSchedule(Animal animal, Date feedingTime, Boolean foodType) {
        this.animal = animal;
        this.feedingTime = feedingTime;
        this.foodType = foodType;
        return this;
    }

    public Boolean checkIfFed() {
        if (feedingTime.before(new Date())) {
            animal.feed();
            return true;
        } else {
            System.out.println("Животное ещё не поело.");
        }
        return false;
    }
}package hse.zoo.Domain.entities;

import java.util.List;

import hse.zoo.Domain.valueobjects.AnimalSpecies;
import hse.zoo.Domain.valueobjects.EnclosureSize;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.ToString;

@RequiredArgsConstructor
@ToString
public class Enclosure {

    private List<AnimalSpecies> type; // Sets which species are allowed to live in the enclosure

    private EnclosureSize size;

    @Getter
    private Integer currentAnimalCount = 0;

    private Integer maxAnimalCount;

    public Enclosure(List<String> type, Integer height, Integer width, Integer length, Integer maxAnimalCount) {
        this.type = type.stream().map(AnimalSpecies::new).toList();
        this.size = new EnclosureSize(length, width, height);
        this.maxAnimalCount = maxAnimalCount;
    }

    public Boolean isAllowed(AnimalSpecies animalSpecies) {
        return type.contains(animalSpecies);
    }
    
    public Enclosure addAnimal(Animal animal) {
        if (currentAnimalCount < maxAnimalCount) {
            AnimalSpecies animalSpecies = animal.getSpecies();
            if (isAllowed(animalSpecies)) {
                currentAnimalCount++;
                animal.moveTo(this);
                return this;
            }
            throw new IllegalArgumentException("Animal species " + animalSpecies + " is not allowed in this enclosure.");
        } else {
            throw new IllegalArgumentException("Enclosure is full.");
        }
    }

    public Enclosure removeAnimal(Animal animal) {
        if (currentAnimalCount > 0) {
            currentAnimalCount--;
            animal.moveTo(null);
            return this;
        }
        throw new IllegalArgumentException("Enclosure is empty.");
    }
    
    public Enclosure clean() {
        System.out.println("Enclosure was cleaned.");
        return this;
    }
}
package hse.zoo.Domain.events;

import java.util.Date;

import lombok.Getter;

public class FeedingTimeEvent {

    @Getter
    private final Integer animalId;

    @Getter
    private final Boolean type;

    @Getter
    private final Date date;
    
    public FeedingTimeEvent(Integer animalId, Boolean type, Date date) {
        this.animalId = animalId;
        this.type = type;
        this.date = date;
    }
    
}package hse.zoo.Domain.events;

import java.util.Date;

import lombok.Getter;

public class AnimalMovedEvent {

    @Getter
    private final Integer animalId;

    @Getter
    private final Integer fromEnclosureId;

    @Getter
    private final Integer toEnclosureId;

    @Getter
    private final Date date;
    
    public AnimalMovedEvent(Integer animalId, Integer fromEnclosureId, Integer toEnclosureId, Date date) {
        this.animalId = animalId;
        this.fromEnclosureId = fromEnclosureId;
        this.toEnclosureId = toEnclosureId;
        this.date = date;
    }
    
}package hse.zoo.Domain.interfaces.repositoryInterfaces;

import hse.zoo.Domain.entities.FeedingSchedule;
import java.util.List;

public interface IFeedingScheduleRepository {
    Integer addFeedingSchedule(FeedingSchedule schedule);
    Boolean deleteFeedingSchedule(Integer id);
    FeedingSchedule getFeedingSchedule(Integer id);
    List<FeedingSchedule> getAllFeedingSchedules();
    Boolean checkIfFed(Integer id);
    FeedingSchedule changeSchedule(Integer scheduleId, FeedingSchedule newSchedule);
    FeedingSchedule getSchedule(Integer id);
}
package hse.zoo.Domain.interfaces.repositoryInterfaces;

import hse.zoo.Domain.entities.Enclosure;
import java.util.List;

public interface IEnclosureRepository {
    Integer addEnclosure(Enclosure enclosure);
    Enclosure getEnclosure(Integer id);
    Boolean deleteEnclosure(Integer id);
    List<Enclosure> getAllEnclosures();
    Integer findEnclosure(Enclosure enclosure);
}
package hse.zoo.Domain.interfaces.repositoryInterfaces;

import hse.zoo.Domain.entities.Animal;
import java.util.List;

public interface IAnimalRepository {
    Integer addAnimal(Animal animal);
    Animal getAnimal(Integer id);
    Boolean deleteAnimal(Integer id);
    List<Animal> getAllAnimals();
    Integer findAnimal(Animal animal);
}package hse.zoo.Domain.interfaces.servicesInterfaces;

import hse.zoo.Domain.entities.FeedingSchedule;

public interface IFeedingOrganizationService {

    Integer addFeedingSchedule(FeedingSchedule schedule);

    Boolean deleteFeedingSchedule(Integer scheduleId);

    FeedingSchedule changeSchedule(Integer scheduleId, FeedingSchedule newSchedule);

    Boolean checkIfFed(Integer scheduleId);

    FeedingSchedule getSchedule(Integer id);
    
}package hse.zoo.Domain.interfaces.servicesInterfaces;

import hse.zoo.Domain.entities.Animal;
import hse.zoo.Domain.entities.Enclosure;

public interface IAnimalTransferService {

    Integer addAnimal(Animal animal);

    Boolean deleteAnimal(Integer animalId);

    Integer addEnclosure(Enclosure enclosure);

    Boolean deleteEnclosure(Integer enclosureId);

    void transferAnimalToEnclosure(Integer animalId, Integer enclosureId);

}
package hse.zoo.Domain.interfaces.servicesInterfaces;

import java.util.List;

import hse.zoo.Domain.entities.Animal;
import hse.zoo.Domain.entities.Enclosure;
import hse.zoo.Domain.entities.FeedingSchedule;

public interface IZooStatisticsService {

    List<Animal> getAllAnimals();

    List<Enclosure> getAllEnclosures();

    List<FeedingSchedule> getAllFeedingSchedules();

    List<Animal> getAllAnimalsInEnclosure(Integer enclosureId);

    List<Animal> getAllAnimalsWithoutEnclosure();

    List<Enclosure> getEmptyEnclosures();

    List<Animal> getIllAnimals();

}package hse.zoo.Domain.valueobjects;

import lombok.Getter;

public class FavouriteFood {
    
    @Getter
    private String food;
    
    public FavouriteFood(String food) {
        if (food.matches(".*\\d.*") || food.isEmpty()) {
            throw new IllegalArgumentException("Invalid food name: " + food);
        } else {
            this.food = food;
        }
    }
}
package hse.zoo.Domain.valueobjects;

import lombok.Getter;

public class AnimalSpecies {

    @Getter
    private String name;

    public AnimalSpecies(String name) {
        if (name.matches(".*\\d.*") || name.isEmpty()) {
            throw new IllegalArgumentException("Invalid species name: " + name);
        } else {
            this.name = name;
        }
    }
}
package hse.zoo.Domain.valueobjects;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class EnclosureSize {

    @Getter
    private Integer length;

    @Getter
    private Integer width;

    @Getter
    private Integer height;

    public EnclosureSize(Integer length, Integer width, Integer height) {
        if (length < 0 || width < 0 || height < 0) {
            throw new IllegalArgumentException("The size of the enclosure cannot be less than 0");
        }
        this.length = length;
        this.width = width;
        this.height = height;
    }

}package hse.zoo.Application.services;

import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Component;
import java.util.Date;

import hse.zoo.Domain.entities.Animal;
import hse.zoo.Domain.entities.Enclosure;
import hse.zoo.Domain.events.AnimalMovedEvent;
import hse.zoo.Domain.interfaces.repositoryInterfaces.IAnimalRepository;
import hse.zoo.Domain.interfaces.repositoryInterfaces.IEnclosureRepository;
import hse.zoo.Domain.interfaces.servicesInterfaces.IAnimalTransferService;
import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class AnimalTransferService implements IAnimalTransferService {

    private final ApplicationEventPublisher publisher;

    private final IAnimalRepository animalRepository;

    private final IEnclosureRepository enclosureRepository;

    @Override
    public Integer addAnimal(Animal animal) {
        return animalRepository.addAnimal(animal);
    }

    @Override
    public Boolean deleteAnimal(Integer animalId) {
        return animalRepository.deleteAnimal(animalId);
    }

    @Override
    public Integer addEnclosure(Enclosure enclosure) {
        return enclosureRepository.addEnclosure(enclosure);
    }

    @Override
    public Boolean deleteEnclosure(Integer enclosureId) {
        return enclosureRepository.deleteEnclosure(enclosureId);
    }

    @Override
    public void transferAnimalToEnclosure(Integer animalId, Integer enclosureId) {
        Animal animal = animalRepository.getAnimal(animalId);
        Enclosure currentEnclosure = animal.getEnclosure();
        if (currentEnclosure != null) {
            currentEnclosure.removeAnimal(animal);
        }
        Enclosure newEnclosure = enclosureRepository.getEnclosure(enclosureId);
        newEnclosure.addAnimal(animal);
        publisher.publishEvent(new AnimalMovedEvent(animalId, enclosureRepository.findEnclosure(currentEnclosure), enclosureId, new Date()));
    }
}
package hse.zoo.Application.services;

import java.util.ArrayList;
import java.util.List;

import org.springframework.stereotype.Component;

import hse.zoo.Domain.entities.Animal;
import hse.zoo.Domain.entities.Enclosure;
import hse.zoo.Domain.entities.FeedingSchedule;
import hse.zoo.Domain.interfaces.repositoryInterfaces.IAnimalRepository;
import hse.zoo.Domain.interfaces.repositoryInterfaces.IEnclosureRepository;
import hse.zoo.Domain.interfaces.repositoryInterfaces.IFeedingScheduleRepository;
import hse.zoo.Domain.interfaces.servicesInterfaces.IZooStatisticsService;
import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class ZooStatisticsService implements IZooStatisticsService {

    private final IAnimalRepository animalRepository;

    private final IEnclosureRepository enclosureRepository;

    private final IFeedingScheduleRepository feedingRepository;

    @Override
    public List<Animal> getAllAnimals() {
        return animalRepository.getAllAnimals();
    }

    @Override
    public List<Enclosure> getAllEnclosures() {
        return enclosureRepository.getAllEnclosures();
    }

    @Override
    public List<FeedingSchedule> getAllFeedingSchedules() {
        return feedingRepository.getAllFeedingSchedules();
    }

    @Override
    public List<Animal> getAllAnimalsInEnclosure(Integer enclosureId) {
        Enclosure enclosure = enclosureRepository.getEnclosure(enclosureId);
        List<Animal> animals = getAllAnimals();
        animals.removeIf(animal -> animal.getEnclosure() != enclosure);
        return animals;
    }

    @Override
    public List<Animal> getAllAnimalsWithoutEnclosure() {
        List<Animal> animals = getAllAnimals();
        animals.removeIf(animal -> animal.getEnclosure() != null);
        return animals;
    }

    @Override
    public List<Enclosure> getEmptyEnclosures() {
        List<Enclosure> enclosures = new ArrayList<>();
        for (Enclosure enclosure : enclosureRepository.getAllEnclosures()) {
            if (enclosure.getCurrentAnimalCount() == 0) {
                enclosures.add(enclosure);
            }
        }
        return enclosures;
    }

    @Override
    public List<Animal> getIllAnimals() {
        List<Animal> animals = new ArrayList<>();
        for (Animal animal : animalRepository.getAllAnimals()) {
            if (animal.getIsHealthy() == false) {
                animals.add(animal);
            }
        }
        return animals;
    }
}package hse.zoo.Application.services;

import java.util.Date;

import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Component;

import hse.zoo.Domain.entities.FeedingSchedule;
import hse.zoo.Domain.events.FeedingTimeEvent;
import hse.zoo.Domain.interfaces.repositoryInterfaces.IAnimalRepository;
import hse.zoo.Domain.interfaces.repositoryInterfaces.IFeedingScheduleRepository;
import hse.zoo.Domain.interfaces.servicesInterfaces.IFeedingOrganizationService;
import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class FeedingOrganizationService implements IFeedingOrganizationService {

    private final ApplicationEventPublisher publisher;

    private final IAnimalRepository animalRepository;

    private final IFeedingScheduleRepository feedingScheduleRepository;

    @Override
    public Integer addFeedingSchedule(FeedingSchedule schedule) {
        return feedingScheduleRepository.addFeedingSchedule(schedule);
    }

    @Override
    public Boolean deleteFeedingSchedule(Integer scheduleId) {
        return feedingScheduleRepository.deleteFeedingSchedule(scheduleId);
    }

    @Override
    public FeedingSchedule changeSchedule(Integer scheduleId, FeedingSchedule newSchedule) {
        return feedingScheduleRepository.changeSchedule(scheduleId, newSchedule);
    }

    @Override
    public FeedingSchedule getSchedule(Integer id) {
        return feedingScheduleRepository.getSchedule(id);
    }

    @Override
    public Boolean checkIfFed(Integer scheduleId) {
        Boolean result = feedingScheduleRepository.checkIfFed(scheduleId);
        FeedingSchedule schedule = getSchedule(scheduleId);
        if (result) {
            publisher.publishEvent(new FeedingTimeEvent(animalRepository.findAnimal(schedule.getAnimal()), schedule.getFoodType(), new Date()));
        }
        return result;
    }
    
}package hse.zoo.Application.eventHandlers;

import hse.zoo.Domain.events.FeedingTimeEvent;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

@Component
public class FeedingTimeHandler {

    @EventListener
    public void handleEvent(FeedingTimeEvent event) {
        System.out.println("Обработчик: животное с id " + event.getAnimalId() +
                " поело " + event.getType());
    }
}

package hse.zoo.Application.eventHandlers;

import hse.zoo.Domain.events.AnimalMovedEvent;
import lombok.RequiredArgsConstructor;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
public class MoveAnimalHandler {

    @EventListener
    public void handleEvent(AnimalMovedEvent event) {
        System.out.println("Обработчик: животное с id " + event.getAnimalId() +
                " перемещёно из вольера с id " + event.getFromEnclosureId() +
                " в вольер с id " + event.getToEnclosureId() +
                " в " + event.getDate());
    }

}package hse.zoo.Application.facade;

import java.util.Date;
import java.util.List;

import org.springframework.stereotype.Component;

import hse.zoo.Domain.entities.Animal;
import hse.zoo.Domain.entities.Enclosure;
import hse.zoo.Domain.entities.FeedingSchedule;
import hse.zoo.Domain.interfaces.repositoryInterfaces.IAnimalRepository;
import hse.zoo.Domain.interfaces.repositoryInterfaces.IEnclosureRepository;
import hse.zoo.Domain.interfaces.servicesInterfaces.IAnimalTransferService;
import hse.zoo.Domain.interfaces.servicesInterfaces.IFeedingOrganizationService;
import hse.zoo.Domain.interfaces.servicesInterfaces.IZooStatisticsService;
import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class ZooFacade {

    private final IAnimalTransferService animalTransferService;

    private final IFeedingOrganizationService feedingOrganizationService;

    private final IZooStatisticsService zooStatisticsService;

    private final IAnimalRepository animalRepository;

    private final IEnclosureRepository enclosureRepository;

    public Integer addAnimal(Integer enclosureId, String name, Date birthDate, Boolean sex, String favouriteFood, Boolean isHealthy, String species) {
        Integer animalId = animalTransferService.addAnimal(new Animal(species, name, birthDate, sex, favouriteFood, isHealthy));
        if (enclosureId != null) {
            animalTransferService.transferAnimalToEnclosure(animalId, enclosureId);
        }
        return animalId;
    }
    
    public Boolean deleteAnimal(Integer animalId) {
        return animalTransferService.deleteAnimal(animalId);
    }

    public Integer addEnclosure(List<String> species, Integer width, Integer height, Integer length, Integer maxAnimalCount) {
        Enclosure enclosure = new Enclosure(species, width, height, length, maxAnimalCount);
        Integer enclosureId = animalTransferService.addEnclosure(enclosure);
        return enclosureId;
    }

    public Boolean deleteEnclosure(Integer enclosureId) {
        return animalTransferService.deleteEnclosure(enclosureId);
    }

    public void transferAnimalToEnclosure(Integer animalId, Integer enclosureId) {
        animalTransferService.transferAnimalToEnclosure(animalId, enclosureId);
    }

    public Integer addFeedingSchedule(Integer animalId, Date feedingTime, Boolean foodType) {
        Animal animal = animalRepository.getAnimal(animalId);
        FeedingSchedule schedule = new FeedingSchedule(animal, feedingTime, foodType);
        return feedingOrganizationService.addFeedingSchedule(schedule);
    }

    public Boolean deleteFeedingSchedule(Integer scheduleId) {
        return feedingOrganizationService.deleteFeedingSchedule(scheduleId);
    }

    public void changeSchedule(Integer scheduleId, Integer animalId, Date feedingTime, Boolean foodType) {
        FeedingSchedule schedule = new FeedingSchedule(animalRepository.getAnimal(animalId), feedingTime, foodType);
        feedingOrganizationService.changeSchedule(scheduleId, schedule);
    }

    public FeedingSchedule getSchedule(Integer scheduleId) {
        return feedingOrganizationService.getSchedule(scheduleId);
    }

    public List<FeedingSchedule> getSchedules() {
        return zooStatisticsService.getAllFeedingSchedules();
    }

    public Animal getAnimal(Integer animalId) {
        return animalRepository.getAnimal(animalId);
    }

    public List<Animal> getAnimals(){
        return zooStatisticsService.getAllAnimals();
    }

    public Enclosure getEnclosure(Integer enclosureId) {
        return enclosureRepository.getEnclosure(enclosureId);
    }

    public List<Enclosure> getEnclosures() {
        return zooStatisticsService.getAllEnclosures();
    }

    public List<Animal> getAnimalsInEnclosure(Integer enclosureId) {
        return zooStatisticsService.getAllAnimalsInEnclosure(enclosureId);
    }

    public List<Animal> getAnimalsWithoutEnclosure() {
        return zooStatisticsService.getAllAnimalsWithoutEnclosure();
    }

    public List<Enclosure> getEmptyEnclosures() {
        return zooStatisticsService.getEmptyEnclosures();
    }

    public List<Animal> getIllAnimals() {
        return zooStatisticsService.getIllAnimals();
    }
    
    public void healAnimal(Integer animalId) {
        animalRepository.getAnimal(animalId).heal();
    }
}
package hse.zoo.Infrastructure.repositories;

import hse.zoo.Domain.entities.Enclosure;
import hse.zoo.Domain.interfaces.repositoryInterfaces.IEnclosureRepository;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.stereotype.Component;

@Component
public class EnclosureRepository implements IEnclosureRepository {

    private Integer id_counter = 0;

    private final Map<Integer, Enclosure> enclosures = new ConcurrentHashMap<>();

    @Override
    public Enclosure getEnclosure(Integer id) {
        if (!enclosures.containsKey(id)) {
            throw new IllegalArgumentException("Enclosure with id " + id + " not found");
        }
        return enclosures.get(id);
    }

    @Override
    public Integer addEnclosure(Enclosure enclosure) {
        enclosures.put(id_counter++, enclosure);
        return id_counter - 1;
    }

    @Override
    public Boolean deleteEnclosure(Integer id) {
        if (!enclosures.containsKey(id)) {
            throw new IllegalArgumentException("Enclosure with id " + id + " not found");
        }
        return enclosures.remove(id, enclosures.get(id));
    }

    @Override
    public List<Enclosure> getAllEnclosures() {
        return new ArrayList<>(enclosures.values());
    }

    @Override
    public Integer findEnclosure(Enclosure enclosure) {
        for (Map.Entry<Integer, Enclosure> entry : enclosures.entrySet()) {
            if (entry.getValue().equals(enclosure)) {
                return entry.getKey();
            }
        }
        return null;
    }
    
}package hse.zoo.Infrastructure.repositories;

import hse.zoo.Domain.entities.Animal;
import hse.zoo.Domain.interfaces.repositoryInterfaces.IAnimalRepository;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.stereotype.Component;

@Component
public class AnimalRepository implements IAnimalRepository {

    private Integer id_counter = 0;

    private final Map<Integer, Animal> animals = new ConcurrentHashMap<>();

    @Override
    public Animal getAnimal(Integer id) {
        if (!animals.containsKey(id)) {
            throw new IllegalArgumentException("Animal with id " + id + " not found");
        }
        return animals.get(id);
    }

    @Override
    public Integer addAnimal(Animal animal) {
        animals.put(id_counter++, animal);
        return id_counter - 1;
    }

    @Override
    public Boolean deleteAnimal(Integer id) {
        if (!animals.containsKey(id)) {
            throw new IllegalArgumentException("Animal with id " + id + " not found");
        }
        return animals.remove(id, animals.get(id));
    }

    @Override
    public List<Animal> getAllAnimals() {
        return new ArrayList<>(animals.values());
    }

    @Override
    public Integer findAnimal(Animal animal) {
        for (Map.Entry<Integer, Animal> entry : animals.entrySet()) {
            if (entry.getValue().equals(animal)) {
                return entry.getKey();
            }
        }
        return null;
    }

}package hse.zoo.Infrastructure.repositories;

import hse.zoo.Domain.entities.FeedingSchedule;
import hse.zoo.Domain.interfaces.repositoryInterfaces.IFeedingScheduleRepository;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.stereotype.Component;

@Component
public class FeedingScheduleRepository implements IFeedingScheduleRepository {

    private Integer id_counter = 0;

    private final Map<Integer, FeedingSchedule> schedules = new ConcurrentHashMap<>();

    @Override
    public FeedingSchedule getFeedingSchedule(Integer id) {
        if (!schedules.containsKey(id)) {
            throw new IllegalArgumentException("FeedingSchedule with id " + id + " not found");
        }
        return schedules.get(id);
    }

    @Override
    public Integer addFeedingSchedule(FeedingSchedule schedule) {
        schedules.put(id_counter++, schedule);
        return id_counter - 1;
    }

    @Override
    public Boolean deleteFeedingSchedule(Integer id) {
        if (!schedules.containsKey(id)) {
            throw new IllegalArgumentException("FeedingSchedule with id " + id + " not found");
        }
        return schedules.remove(id, schedules.get(id));
    }

    @Override
    public List<FeedingSchedule> getAllFeedingSchedules() {
        return new ArrayList<>(schedules.values());
    }

    @Override
    public Boolean checkIfFed(Integer id) {
        if (!schedules.containsKey(id)) {
            throw new IllegalArgumentException("FeedingSchedule with id " + id + " not found");
        }
        return schedules.get(id).checkIfFed();
    }

    @Override
    public FeedingSchedule changeSchedule(Integer scheduleId, FeedingSchedule newSchedule) {
        if (!schedules.containsKey(scheduleId)) {
            throw new IllegalArgumentException("FeedingSchedule with id " + scheduleId + " not found");
        }
        schedules.get(scheduleId).changeSchedule(newSchedule.getAnimal(), newSchedule.getFeedingTime(), newSchedule.getFoodType());
        return newSchedule;
    }

    @Override
    public FeedingSchedule getSchedule(Integer id) {
        if (!schedules.containsKey(id)) {
            throw new IllegalArgumentException("FeedingSchedule with id " + id + " not found");
        }
        return schedules.get(id);
    }

}